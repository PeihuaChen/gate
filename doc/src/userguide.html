<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <TITLE>The GATE User Guide</TITLE>
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF">
<!-- $Id$ -->


<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<H1>
<IMG SRC="gateHeader.gif" ALT="GATE" HEIGHT=76 WIDTH=356></H1>

<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<CENTER>
<H1>The GATE User Guide</H1>
<H2><A HREF=http://www.dcs.shef.ac.uk/~hamish/>Hamish Cunningham</A></H2>
<H2><A HREF=http://www.dcs.shef.ac.uk/~diana/>Diana Maynard</A></H2>
</CENTER>

<P>
<B>
This version of the document is for GATE version 2 alpha 1, of
March 2001. It is <B>incomplete</B>, probably inaccurate and almost
certainly quite annoying, but that's all Bill Gate's fault.
</B>

<P>
Contents:
<UL>
<LI>
<A HREF=#introduction>Introduction</A>
<LI>
<A HREF=#the-development-environment>The Development Environment</A>
<LI>
<A HREF=#the-framework>The Framework</A>
  <UL>
  <LI>
  <A HREF=#the-annotation-model>The Annotation Model</A>
  </UL>
<LI>
<A HREF=#design>Design</A>
</UL>

<P>
For installation and build instructions 
see the <A HREF=install.html>installation guide</A>.


<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<A NAME=introduction></A>
<H2>Introduction</H2>

<P>
GATE, a General Architecture for Text Engineering
\cite{Cun96b,Cun97a,Cun98,Cun99a,Cun00a},
is a software architecture for Language Engineering \cite{Cun99b}.
More specifically, it is three things: an <B>architecture</B>; 
a <B>framework</B>; a <B>development environment</B>.

<P>
By architecture we mean an abstract description of how a language processing
system may usefully be constructed, the types of component typically
used and so on.
By framework we mean an object-oriented class library that implements the
architecture and provides a range of services that are useable in a variety
of application contexts. One such application is a development environment
built on top of the framework. The development environment is analogous to
systems like Mathematica for Mathematicians, or JBuilder for Java
programmers: it provides a convenient graphical environment for research and
development of language processing software.

<P>
Version 1 of GATE was released in 1996. It was written in C++ and Tcl, has
been licenced by several hundred organisations, and used in a wide range of
language analysis contexts including Information Extraction (IE -
\cite{Gai98a,Cun99c}) in English, Greek, Spanish, Swedish, German, Italian and
French.

<P>
Version 2 of GATE was released in Spring 2001. It is written in Java,
and is available as open source free software under the GNU licence
at <A HREF=http://gate.ac.uk/>http://gate.ac.uk/</A>.

<P>
The rest of this section gives a general introduction to the system.
The rest of the document covers:
<UL>
<LI>
how to use the
<A HREF=#the-development-environment>development environment</A>
<LI>
how to use the <A HREF=#the-framework>framework</A>
<LI>
the <A HREF=#design>design principles</A> of the architecture and framework.
</UL>


<!---------------------------------------------------------------------->
<H3>Architectural principles</H3>

<P>
A central idea behind the GATE architecture is that there should be
no requirement for users to commit to any particular theory of
language processing: the architecture strives to be non-prescriptive and
theory-neutral. Therefore there is a very general model of components and the
data structures they share. This is, of course, both a strength and a
weakness.

<P>
(Almost) everything in GATE is a component. Components are
reusable software chunks with well-defined interfaces
that are conceptually separate from GATE itself.
All component sets are user-extensible and together are called CREOLE - a
Collection of REusable Objects for Language Engineering.


<!---------------------------------------------------------------------->
<H3>GATE-based development</H3>

<P>
The framework is a backplane into which plug CREOLE components.
The user gives the system a list of URLs to search when it starts up,
and components at those locations are loaded by the system. (To be precise
only their configuration data is loaded to begin with; the actual classes
are loaded when the user requests the instantiation of a resource.)

<P>
The backplane performs these functions:
<UL>
<LI>
component discovery, bootstrapping, loading and reloading;
<LI>
native data structures for common information types;
<LI>
generalised data storage and process execution.
</UL>

<P>
A set of components plus the framework is a deployment unit which can be
embedded in another application.

<P>
The key task of the 
development environment is to facilitate constructing components.


<!---------------------------------------------------------------------->
<H3>Component types</H3>

<P>
GATE components are one of three types of specialised Java Beans:

<P><B>Resource:</B><BR>
The top-level interface, which describes all components. What all 
components share in common is that they can be loaded at runtime,
and that the set of components is extendable by clients. They
have Features, which are represented externally to the system as
"meta-data" in a format such as RDF, plain XML, or Java properties.
Resources should probably all be Java beans.

<P><B>ProcessingResource:</B><BR>
Is a resource that is runnable, may be invoked remotely (via RMI),
and lives in class files. In order to load a PR the system just
needs to know where to find the class or jar files (which will 
also include the metadata).

<P><B>LanguageResource:</B><BR>
Is a resource that consists of data, accessed via a Java abstraction
layer. They live in relational databases.

<P><B>VisualResource:</B><BR>
Is a visual Java bean, component of GUIs, including of the main GATE 
gui.  Like PRs they live in .class or .jar files.


<!---------------------------------------------------------------------->
<H3>Bits and pieces</H3>


There are built in components for common processing and data visualisation
tasks.

There is a finite state transduction language operating over
annotations on text, called JAPE, a Jolly Advanced Pattern Eater. JAPE 
is based on Doug Appelt's TextPro language.

There is automated measurement: precision, recall, diff over annotations
on text.

Support for documents in XML, SGML, HTML, RTF, email.

Full Unicode support including editing in a number of languages (not
supported by native JDK; thanks to Mark Leisher for help with this).




<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<A NAME=the-development-environment></A><H2>Development Environment</H2>



<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<A NAME=the-framework></A><H2>The Framework</H2>



<!---------------------------------------------------------------------->
<A NAME=the-annotation-model></A><H3>The Annotation Model</H3>


<!---------------------------------------------------------------------->
<!---------------------------------------------------------------------->
<A NAME=design></A><H2>Design</H2>

<P>
GATE is a backplane into which specialised Java Beans plug.
These beans are loose-coupled with respect to each other - they communicate
entirely by means of the GATE framework.
Inter-component communication is handled by model components -
LanguageResources, and events.

<P>
Components are defined by conformance to various interfaces (e.g.
LanguageResource), ensuring
separation of interface and implementation.

<P>
Distribution and parallelism (NOT fully working as yet)
is handled by controller components (and by distributing data
over HTTP and JDBC).

<P>
The reason for adding to the normal bean initialisation mech is that
LRs, PRs and VRs all have characteristic parameterisation
phases; the GATE resources/components model makes explicit these phases.


<!-------------------------------------------------------------------->
<A NAME=patterns></A><H3>Patterns</H3>

<P>
GATE is structured around a number of what we might call principles, or
patterns, or alternatively, clever ideas stolen from better minds than
mine. These patterns are:
<UL>
<LI>
modelling most things as extensible sets of <A
HREF=#components>components</A>;
<LI>
separating components into
<A HREF=#mvc>model, view, or controller</A> types;
<LI>
hiding implementation behind <A HREF=#interfaces>interfaces</A>.
</UL>

<P>
Four interfaces in the top-level package describe the GATE view of
components:
Resource, ProcessingResource, LanguageResource and VisualResource.


<!-------------------------------------------------------------------->
<A NAME=components></A><H3>Components</H3>

<!------------------>
<H4>Architectural Principle</H4>

<P>
Wherever users of the architecture may wish to extend the set of a
particular type of entity, those types should be expressed as components.

<P>
Another way to express this is to say that the architecture is based on
<I>agents</I>. I've avoided this in the past because of an association
between this term and the idea of bits of code moving around between
machines of their own volition. I take this to be somewhat pointless, and
probably the result of an anthropomorphic obsession with mobility as a
correlate of intelligence. If we drop this connotation, however, we can
say that GATE is an agent-based architecture. If we want to, that is.


<!------------------>
<H4>Framework Expression</H4>

<P>
Many of the classes in the framework are components, by which we mean
classes that conform to an interface with certain standard properties. In
our case these properties are based on the Java Beans component
architecture, with the addition of component metadata, automated loading
and standardised storage, threading and distribution.

<P>
All components inherit from Resource, via one of:
<UL>
<LI>
LanguageResource (LR) represents entities such as lexicons, corpora or
ontologies;
<LI>
VisualResource (VR) represents visualisation and editing components that
participate in GUIs;
<LI>
ProcessingResource (PR) represents entities that are primarily algorithmic,
such as parsers, generators or ngram modellers.
</UL>


<!-------------------------------------------------------------------->
<A NAME=mvc></A><H3>Model, view, controller</H3>

<P>
According to Buschmann et al
(Pattern-Oriented Software Architecture, 1996),
the Model-View-Controller (MVC)
pattern 
<BLOCKQUOTE>
...divides an interactive application into three components. The model
contains the core functionality and data. Views display information to the
user. Controllers handle user input. Views and controllers together comprise
the user interface. A change-propagation mechanism ensures consistency between
the user interface and the model. [p.125]
</BLOCKQUOTE>
A variant of MVC, the Document-View pattern, 
<BLOCKQUOTE>
...relaxes the separation of view and controller... The View component of
Document-View combines the responsibilities of controller and view in MVC, and
implements the user interface of the system.
</BLOCKQUOTE>
A benefit of both arrangements is that 
<BLOCKQUOTE>
...loose coupling of the document and view components enables multiple
simultaneous synchronized but different views of the same document.
</BLOCKQUOTE>

<P>
Geary (Graphic Java 2, 3rd Edtn., 1999) gives a slightly different view:
<BLOCKQUOTE>
MVC separates applications into three types of objects:
<UL>
<LI>
<B>Models:</B> Maintain data and provide data accessor methods
<LI>
<B>Views:</B> Paint a visual representation of some or all of a model's data
<LI>
<B>Controllers:</B> Handle events
... By encapsulating what other architectures intertwine, MVC applications are
much more flexible and reusable than their traditional counterparts.
</UL>
[pp. 71, 75]
</BLOCKQUOTE>
Swing, the Java user interface framework, uses
<BLOCKQUOTE>
a specialised version of the classic MVC meant to support pluggable look and
feel instead of applications in general.
[p. 75]
</BLOCKQUOTE>

<P>
GATE may be regarded as an MVC architecture in two ways:
<UL>
<LI>
directly, because we use the Swing toolkit for the GUIs;
<LI>
by analogy, where LRs are models, VRs are views and PRs are controllers.
Of these, the latter sits least
easily with the MVC scheme, as PRs may indeed be controllers but may also
not be.
</UL>


<!-------------------------------------------------------------------->
<A NAME=interfaces></A><H3>Interfaces</H3>

<!------------------>
<H4>Architectural Principle</H4>

<P>
The implementation of types should generally be hidden from the clients of
the architecture.


<!------------------>
<H4>Framework Expression</H4>

<P>
With a few exceptions (such as for utility classes),
clients of the framework work exclusively with the <TT>gate.*</TT> package.
This
package is composed almost entirely of interface definitions.
Instantiations of these interfaces are obtained via a <TT>DataStore</TT>
class (which models databases of various types) or via the
<TT>Transients</TT> class (which creates objects unattached to any
persistent store).

<P>
<TT>DataStore</TT> and <TT>Transients</TT> are factory classes.

<P>
The subsidiary packages of GATE provide the implementations of the
<TT>gate.*</TT> interfaces that are accessed via factories. They
themselves avoid directly constructing classes from other packages
(with a few exceptions, such as JAPE's need for unattached annotation
sets). Instead they use the factories (which may be obtained from existing
<TT>LanguageResources</TT> via the <TT>getDataStore</TT> method).




</BODY>
</HTML>

