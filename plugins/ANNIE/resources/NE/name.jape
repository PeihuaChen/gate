/*
*  name.jape
*
* Copyright (c) 1998-2001, The University of Sheffield.
*
*  This file is part of GATE (see http://gate.ac.uk/), and is free
*  software, licenced under the GNU Library General Public License,
*  Version 2, June 1991 (in the distribution as file licence.html,
*  and also available at http://gate.ac.uk/gate/licence.html).
*
*  Diana Maynard, 02 Aug 2001
* 
*  $Id$
*/

Phase:	Name
Options: control = appelt

///////////////////////////////////////////////////////////////

// Person Rules

/////////////////////////////////////////////////////////////////
Macro: TITLE
(
 {Lookup.majorType == title}
 (SPACE)?
)

Macro: INITIALS
// one or more initials separated by an optional dot and/or space
(
 ({Token.orth == upperInitial, Token.length =="1"}
  ({Token.string == "."})?
  (SPACE)?
 )+
)

Macro: INITIALS2
// initials not separated by a dot or space are tokenised as 
// allCaps rather than UpperInitial
(
 {Token.orth == allCaps, Token.length == "2"} |
 {Token.orth == allCaps, Token.length == "3"}
)


Macro: FIRSTNAME
// first name from gaz, or initials
//(
// {Lookup.majorType == person_first, Lookup.minorType == male}|
// {Lookup.majorType == person_first, Lookup.minorType == female}|
// (INITIALS)
//)

(
 ({FirstPerson.gender == male} |
  {FirstPerson.gender == female})
 |
 (INITIALS)
)
Macro: FIRSTNAMEAMBIG
//ambiguous first name from gaz - some rules might exclude these 
(
 {Lookup.majorType == person_first, Lookup.minorType == ambig}
)

Macro: LASTNAME
// possible single last name beginning with a capital letter
(
 {Token.orth == upperInitial} |
  {Token.orth == allCaps} |
 {Token.orth == mixedCaps}
)


Macro: PERSONENDING
(
 ({Token.string == "Jr"} ({Token.string == "."})? ) |
 ({Token.string == "jr"} ({Token.string == "."})? ) |
 ({Token.string == "Sr"} ({Token.string == "."})? ) |
 ({Token.string == "sr"} ({Token.string == "."})? ) |
 {Token.string == "II"} |
 {Token.string == "III"}
)


///////////////////////////////////////////////////////////
// Person Rules

Rule:	GazPerson
Priority: 50
(
 {Lookup.majorType == person_full, Lookup.minorType == normal}
)
:person -->
{
gate.AnnotationSet person = (gate.AnnotationSet)bindings.get("person");
gate.Annotation personAnn = (gate.Annotation)person.iterator().next();
gate.FeatureMap features = Factory.newFeatureMap();
features.put("kind", "personName");
features.put("rule", "GazPerson");
annotations.add(person.firstNode(), person.lastNode(), "TempPerson",
features);
}


Rule:	GazPersonFirst
Priority: 20
(
 {FirstPerson}
)
:person 
( 
 (SPACE)
 {Token.orth == upperInitial, Token.length == "1"}
)?
-->
{
gate.AnnotationSet person = (gate.AnnotationSet)bindings.get("person");
gate.Annotation personAnn = (gate.Annotation)person.iterator().next();
gate.FeatureMap features = Factory.newFeatureMap();
features.put("gender", personAnn.getFeatures().get("gender"));
features.put("kind", "personName");
features.put("rule", "GazPersonFirst");
annotations.add(person.firstNode(), person.lastNode(), "TempPerson",
features);
//annotations.removeAll(person);
}


Rule: PersonFirstContext
Priority: 30
// Anne and Kenton

(
 {Lookup.majorType == person_first}
):personName1
(
 SPACE
 {Token.string == "and"}
 SPACE
)
({Token.orth == upperInitial})
:personName2
 -->
 // :personName1.TempPerson = {kind = "personName", rule = PersonFirstContext},
//:personName2.TempPerson = {kind = "personName", rule = PersonFirstContext}

{
//gate.AnnotationSet personName1 = (gate.AnnotationSet)bindings.get("personName1");
//gate.Annotation person1Ann = (gate.Annotation)personName1.iterator().next();
//gate.FeatureMap features = Factory.newFeatureMap();
//features.put("gender", person1Ann.getFeatures().get("minorType"));
//features.put("kind", "personName");
//features.put("rule", "PersonFirstContext");
//annotations.add(personName1.firstNode(), personName1.lastNode(), "TempPerson",
//features);
//gate.AnnotationSet personName2 = (gate.AnnotationSet)bindings.get("personName2");
//gate.Annotation person2Ann = (gate.Annotation)personName2.iterator().next();
//gate.FeatureMap features = Factory.newFeatureMap();
//features.put("gender", person2Ann.getFeatures().get("minorType"));
//features.put("kind", "personName");
//features.put("rule", "PersonFirstContext");
//annotations.add(personName2.firstNode(), personName2.lastNode(), "TempPerson",
//features);
}


Rule: PersonFirstContext2
Priority: 40
// Anne and I

(
 {Lookup.majorType == person_first}
):person
(
 SPACE
 {Token.string == "and"}
 SPACE
)
({Token.length == "1"})
:personName2
 -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFirstContext2");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}



Rule:	PersonTitle
Priority: 15
// Mr. Jones
// Mr Fred Jones

(
 (TITLE)
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
  (SPACE)? 
 )*
 (LASTNAME)
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
// create an annotation set consisting of all the annotations for person 
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
// create an annotation set consisting of the annotation matching FirstPerson
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
// if the annotation type FirstPerson doesn't exist, do nothing
if (firstPerson != null && firstPerson.size()>0)
{
// if it does exist, take the first element in the set
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
//propagate gender feature (and value) from FirstPerson
  features.put("gender", personAnn.getFeatures().get("gender"));
}
// create some new features
  features.put("kind", "personName");
  features.put("rule", "PersonTitle");
// create a TempPerson annotation and add the features we've created
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}

Rule:	PersonFirstTitle
Priority: 50
// Mr Jones
// Mr Fred

(
 (TITLE)
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
 )
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFirstTitle");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: 	FirstPersonStop
Priority: 20
// surname contains stop words
// e.g. Mary And

(
 (FIRSTNAME (SPACE)?)+
):person
(
 (SPACE {Lookup.majorType == stop}
  (SPACE)?
 )
)
-->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "FirstPersonStop");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: NotFirstPersonStop
Priority: 50
// ambig first name and surname is stop word
// e.g. Will And

(
 ((FIRSTNAMEAMBIG (SPACE)?)+ | 
  {Token.category == PRP}|
  {Token.category == DT}
 )
 (SPACE {Lookup.majorType == stop}
  (SPACE)?
 )
)
:person -->
  :person.TempPerson = {kind = "negative", rule = "NotFirstPersonStop"}


Rule: NotPersonFull
Priority: 50
// A British

(
 {Token.category == DT}
 (SPACE)
)
(
 (LASTNAME)
):unknown
(
 (SPACE PERSONENDING)?
)
-->
{}

Rule: 	PersonFull
Priority: 10
// F.W. Jones
// Fred Jones

(
 ((FIRSTNAME | FIRSTNAMEAMBIG) (SPACE)? )+
 (LASTNAME)
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFull");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: NotPersonFullReverse
Priority: 20
// XYZ, I
(
 (LASTNAME)
 {Token.string == ","}
 (SPACE)?
 {Token.category == PRP}
 (SPACE PERSONENDING)?
)
:unknown 
-->
{}

Rule: 	PersonFullReverse
Priority: 5
// Jones, F.W.
// don't allow Jones, Fred because too ambiguous
// Smith, TF

(
 (LASTNAME)
 {Token.string == ","}
 (SPACE)?
 (INITIALS (SPACE)? )+ 
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFullReverse");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}

Rule:  PersonSaint
Priority: 50
// Note: ensure that it's not a Saints Day first
(
 ({Token.string == "St"} ({Token.string == "."})? |
 {Token.string == "Saint"})
 SPACE
 (FIRSTNAME)
 )
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonSaint");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: PersonLocAmbig
Priority: 40
// Ken London
// Susan Hampshire

// Christian name + Location --> Person's Name
(
 ((FIRSTNAME| INITIALS2) SPACE 
  {Lookup.majorType == location})
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonLocAmbig");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


///////////////////////////////////////////////////////////////////
// Organisation Rules

Macro:  CDG
// cdg is something like "Ltd."
 (
  ({Lookup.majorType == cdg})|
  ({Token.string == ","} 
  (SPACE)
  {Lookup.majorType == cdg})
 )


Macro: SAINT
(
 ({Token.string == "St"} ({Token.string == "."})? |
 {Token.string == "Saint"})
)

Macro: CHURCH
(
{Token.string == "Church"}|{Token.string == "church"}|
{Token.string == "Cathedral"}|{Token.string == "cathedral"}|
{Token.string == "Chapel"}|{Token.string == "chapel"}
)

/////////////////////////////////////////////////////////////
Rule:	GazOrganization
Priority: 15

(
{Lookup.majorType == organization}
(SPACE {Lookup.majorType == organization})?
)
:orgName -->  
  :orgName.TempOrganization = {kind = "orgName", rule=GazOrganization}

Rule:	LocOrganization
Priority: 20
// Ealing Police
(
 ({Lookup.majorType == location} |
  {Lookup.majorType == country_adj})
 SPACE
{Lookup.majorType == organization}
(SPACE {Lookup.majorType == organization})?
)
:orgName -->  
  :orgName.TempOrganization = {kind = "orgName", rule=LocOrganization}


Rule:	OrgXandY
Priority: 20

// Bradford & Bingley
// Bradford & Bingley Ltd
(
 {Token.category == IN}
 (SPACE)
)?

(
 ({Token.category == NNP}
  (SPACE)? )+

 {Token.string == "&"}

 ((SPACE)?
  {Token.orth == upperInitial}
 )+

 (SPACE CDG)?

)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXandY"}


Rule:OrgUni
Priority: 25
// University of Sheffield
// Sheffield University
// A Sheffield University
(
 {Token.string == "University"}
 SPACE
 {Token.string == "of"}
 (SPACE 
 {Token.orth == upperInitial})+
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgDept"}



Rule: OrgDept
Priority: 25
// Department of Pure Mathematics and Physics

(
 {Token.string == "Department"}
 SPACE
 {Token.string == "of"}
 (SPACE 
 {Token.orth == upperInitial})+
 (SPACE
  {Token.string == "and"}
  (SPACE 
   {Token.orth == upperInitial})+
 )?
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgDept"}



Rule:	OrgXKey
Priority: 15

// Aaaa Ltd.
// Xxx Services Ltd. 
// but NOT A XXX Services Ltd.
(
 {Token.category == DT}
 (SPACE)
)?
(
  ({Token.orth == upperInitial} | 
   {Token.orth == allCaps}|
   {Token.orth == mixedCaps}
  )
  SPACE
  (({Token.orth == upperInitial} | {Token.orth == allCaps})
   SPACE)*
 {Lookup.majorType == org_key}
 (SPACE {Lookup.majorType == org_ending})?
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXKey"}


Rule:	OrgXEnding
Priority: 20

// Coca Cola Co.

(
 {Token.category == DT}
 (SPACE)
)?
(
  ({Token.orth == upperInitial} | 
   {Token.orth == allCaps}|
   {Token.orth == mixedCaps})
  SPACE
  (({Token.orth == upperInitial} |
   {Token.orth == allCaps})
   SPACE)?
 {Lookup.majorType == cdg}
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXEnding"}



Rule:	OrgXandYKey
Priority: 20

// Aaaa Ltd.
// Xxx Services Ltd. 
// AA and BB Services Ltd.
// but NOT A XXX Services Ltd.
(
 {Token.category == DT}
 (SPACE)
)?
(
  ({Token.orth == upperInitial} | 
   {Token.orth == allCaps})
  SPACE
  (({Token.string == "and"} | 
    {Token.string == "&"})
   SPACE
   ({Token.orth == upperInitial} | 
   {Token.orth == allCaps})
   SPACE
  )
  (({Token.orth == upperInitial}| 
    {Token.orth == allCaps})
   SPACE)*
 {Lookup.majorType == org_key}
 (SPACE {Lookup.majorType == org_ending})?
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXandYKey"}


Rule:	OrgXsKeyBase
Priority: 20
 
// Gandy's Circus
// Queen's Ware

(
  (({Token.orth == upperInitial} | 
    {Token.orth == allCaps})
   SPACE)?
  (({Token.orth == upperInitial} | 
    {Token.orth == allCaps})
   SPACE)?
  ({Token.orth == upperInitial}
   {Token.string == "'"}
   ({Token.string == "s"})?
   SPACE)
 ({Lookup.majorType == org_key}|
  {Lookup.majorType == org_base})
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXsKeybase"}



Rule: NotOrgXBase
Priority: 100
// not things like British National
// or The University
// NOTE: not sure if we want this for emails or not

(
 ({Token.category == DT}
   SPACE)?
)
(
 ({Lookup.majorType == country_adj}|
  {Token.orth == lowercase})
 SPACE
 ({Lookup.majorType == org_base}|
  {Lookup.majorType == govern_key})
)
:orgName -->
  :orgName.Temp = {kind = "notorgName", rule = "NotOrgXBase"}


Rule:	OrgXBase
Priority: 30

// same as OrgXKey but uses base instead of key
// includes govern_key e.g. academy
// Barclays Bank
// Royal Academy of Art
(
 (
  {Token.category == DT}
  SPACE
 )?
)
(
 ({Token.orth == upperInitial} | 
  {Token.orth == allCaps} |
  {Token.orth == mixedCaps}
 )
  SPACE
  ({Token.orth == upperInitial}
   SPACE)?
 ({Token.orth == upperInitial}
   SPACE)?
 ({Lookup.majorType == org_base}|
  {Lookup.majorType == govern_key})
 (SPACE
  {Token.string == "of"}
  SPACE
  {Token.orth == upperInitial}
  (SPACE
  {Token.orth == upperInitial}
  )?
 )?
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXBase"}


Rule:	OrgPreX
Priority: 30

// Royal Tuscan

(
 {Lookup.majorType == org_pre}
 (SPACE
  {Token.orth == upperInitial})+
 (SPACE {Lookup.majorType == org_ending})?
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgPreX"}




Rule: OrgChurch
Priority: 50
// St. Andrew's Church

(
  (SAINT)
  SPACE
  {Token.orth == upperInitial}
  {Token.string == "'"}({Token.string == "s"})?
  SPACE
  (CHURCH)
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgChurch"}


Rule:OrgPersonAmbig
Priority: 30
// Alexandra Pottery should be org not person
// overrides PersonFull

(
 (FIRSTNAME (SPACE)? )
 ({Lookup.majorType == org_key}|
  {Lookup.majorType == org_base})
 (SPACE {Lookup.majorType == org_ending})?
)
:org 
-->
 :org.TempOrganization= {kind = "orgName", rule = "OrgPersonAmbig"}

 

/////////////////////////////////////////////////////////////////
// Location rules


Rule: 	Location1
Priority: 25
// Lookup = city, country, province, region, water

// Western Europe
// South China sea
(
 (
  {Token.category == DT}
  SPACE
 )?
)
(
 ({Lookup.majorType == loc_key, Lookup.minorType == pre}
  SPACE)?
 {Lookup.majorType == location}
 (SPACE
  {Lookup.majorType == loc_key, Lookup.minorType == post})?
)
:locName -->
  :locName.TempLocation = {kind = "locName", rule = "Location1"}


Rule:	GazLocation
Priority: 50
(
 (
  {Token.category == DT}
  SPACE
 )?
)
  (
	({Lookup.majorType == location})
  )
:locName
  --> 	
 :locName.TempLocation = {kind = "locName", rule=GazLocation}


/////////////////////////////////////////////////////////////////


// Context-based Rules


Rule: FirstNameContext
Priority: 40
// Dear hiranya

(
 {Token.string == "Dear"}
 (SPACE)
)
(
 ({Token.orth == upperInitial} |
  {Token.orth == lowercase})
)
:person -->
  :person.TempPerson = {kind = "personName", rule = "FirstNameContext"}


Rule:InLoc1

(
 {Token.string == "in"}
 (SPACE)
)
(
 {Lookup.majorType == location, Token.orth == allCaps}
)
:locName
-->
 :locName.TempLocation = {kind = "locName", rule = InLoc1}


