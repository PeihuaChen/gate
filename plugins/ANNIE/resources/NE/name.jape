/*
*  name.jape
*
* Copyright (c) 1998-2001, The University of Sheffield.
*
*  This file is part of GATE (see http://gate.ac.uk/), and is free
*  software, licenced under the GNU Library General Public License,
*  Version 2, June 1991 (in the distribution as file licence.html,
*  and also available at http://gate.ac.uk/gate/licence.html).
*
*  Diana Maynard, 02 Aug 2001
* 
*  $Id$
*/

Phase:	Name
Options: control = appelt

///////////////////////////////////////////////////////////////

// Person Rules

/////////////////////////////////////////////////////////////////
Macro: TITLE
(
 {Title}
 (SPACE)?
)

Macro: INITIALS
// one or more initials separated by an optional dot and/or space
(
 ({Token.orth == upperInitial, Token.length =="1"}
  ({Token.string == "."})?
  (SPACE)?
 )+
)

Macro: INITIALS2
// initials not separated by a dot or space are tokenised as 
// allCaps rather than UpperInitial
(
 {Token.orth == allCaps, Token.length == "2"} |
 {Token.orth == allCaps, Token.length == "3"}
)


Macro: FIRSTNAME
// first name from gaz, or initials

(
 ({FirstPerson.gender == male} |
  {FirstPerson.gender == female})
 |
 (INITIALS)
)
Macro: FIRSTNAMEAMBIG
//ambiguous first name from gaz - some rules might exclude these 
(
 {Lookup.majorType == person_first, Lookup.minorType == ambig}
)

//Macro: LASTNAME
// possible single last name beginning with a capital letter
//(
// {Token.orth == upperInitial} |
//  {Token.orth == allCaps} |
// {Token.orth == mixedCaps}
//)


Macro: UPPER
(
 ({Token.category == NNP}| 
 {Token.orth == upperInitial}|
 {Token.orth == mixedCaps} 
)
 
 ({Token.string == "-"}
  {Token.category == NNP}
 )?
)


Macro: PERSONENDING
(
 {Lookup.majorType == person_ending}
)

Macro: PREFIX
(
 ({Lookup.majorType == surname, Lookup.minorType == prefix}
  SPACE)|
 (({Token.string == "O"}|{Token.string == "D"})
  {Token.string == "'"}
 )
)

Macro: DET
(
 ({Token.string == "A"} | {Token.string == "a"} |
  {Token.string == "The"} |{Token.string == "the"}|
  {Token.string == "One"} |{Token.string == "one"})
)

///////////////////////////////////////////////////////////
// Person Rules


Rule: Pronoun
Priority: 1000
//stops personal pronouns being recognised as Initials
(
 {Token.category == PP}|
 {Token.category == PRP}|
 {Token.category == RB}
):pro
-->
{}


Rule:	GazPerson
Priority: 50
(
 {Lookup.majorType == person_full, Lookup.minorType == normal}
)
:person -->
{
gate.AnnotationSet person = (gate.AnnotationSet)bindings.get("person");
gate.Annotation personAnn = (gate.Annotation)person.iterator().next();
gate.FeatureMap features = Factory.newFeatureMap();
features.put("kind", "personName");
features.put("rule", "GazPerson");
annotations.add(person.firstNode(), person.lastNode(), "TempPerson",
features);
}


Rule:	GazPersonFirst
Priority: 20
(
 {FirstPerson}
)
:person 
( 
 (SPACE)
 {Token.orth == upperInitial, Token.length == "1"}
)?
-->
{
gate.AnnotationSet person = (gate.AnnotationSet)bindings.get("person");
gate.Annotation personAnn = (gate.Annotation)person.iterator().next();
gate.FeatureMap features = Factory.newFeatureMap();
features.put("gender", personAnn.getFeatures().get("gender"));
features.put("kind", "personName");
features.put("rule", "GazPersonFirst");
annotations.add(person.firstNode(), person.lastNode(), "TempPerson",
features);
//annotations.removeAll(person);
}


Rule: PersonFirstContext
Priority: 30
// Anne and Kenton

(
 {FirstPerson}
):person1
(
 SPACE
 {Token.string == "and"}
 SPACE
)
({Token.orth == upperInitial})
:person2
 -->

{
//first deal with person1
 gate.FeatureMap features1 = Factory.newFeatureMap();
gate.AnnotationSet person1Set = (gate.AnnotationSet)bindings.get("person1");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)person1Set.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features1.put("gender", personAnn.getFeatures().get("gender"));
}
  features1.put("kind", "personName");
  features1.put("rule", "PersonFirstContext");
annotations.add(person1Set.firstNode(), person1Set.lastNode(), "TempPerson",
features1);
//now deal with person2
gate.FeatureMap features2 = Factory.newFeatureMap();
gate.AnnotationSet person2Set = (gate.AnnotationSet)bindings.get("person2");
  features2.put("kind", "personName");
  features2.put("rule", "PersonFirstContext");
annotations.add(person2Set.firstNode(), person2Set.lastNode(), "TempPerson",
features2);
}



Rule: PersonFirstContext2
Priority: 40
// Anne and I

(
 {FirstPerson}
):person
(
 SPACE
 {Token.string == "and"}
 SPACE
({Token.length == "1"})
)
 -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFirstContext2");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}

Rule: PersonTitleGender
Priority: 18
// use this rule if the title has a feature gender
// Miss F Smith
(
 ({Title.gender == male}|
  {Title.gender == female}
 ) 
 (SPACE)?
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
  (SPACE)? 
 )*
 (UPPER)
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet title = (gate.AnnotationSet)personSet.get("Title");
// if the annotation type title doesn't exist, do nothing
if (title != null && title.size()>0)
{
// if it does exist, take the first element in the set
  gate.Annotation personAnn = (gate.Annotation)title.iterator().next();
//propagate gender feature (and value) from title
  features.put("gender", personAnn.getFeatures().get("gender"));
}
// create some new features
  features.put("kind", "personName");
  features.put("rule", "PersonTitleGender");
// create a TempPerson annotation and add the features we've created
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule:	PersonTitle
Priority: 15
// Mr. Jones
// Mr Fred Jones

(
 (TITLE)+
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
  (SPACE)? 
 )?
 (PREFIX)*
 (UPPER)
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
// create an annotation set consisting of all the annotations for person 
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
// create an annotation set consisting of the annotation matching FirstPerson
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
// if the annotation type FirstPerson doesn't exist, do nothing
if (firstPerson != null && firstPerson.size()>0)
{
// if it does exist, take the first element in the set
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
//propagate gender feature (and value) from FirstPerson
  features.put("gender", personAnn.getFeatures().get("gender"));
}
// create some new features
  features.put("kind", "personName");
  features.put("rule", "PersonTitle");
// create a TempPerson annotation and add the features we've created
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}

Rule:	PersonFirstTitleGender
Priority: 55
// use this rule when we know what gender the title indicates
// Mr Fred

(
 ({Title.gender == male} | {Title.gender == female})
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
 )
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet title = (gate.AnnotationSet)personSet.get("Title");
if (title != null && title.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)title.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFirstTitleGender");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}

Rule:	PersonFirstTitle
Priority: 50
// Mr Jones
// Mr Fred

(
 (TITLE)
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
 )
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFirstTitle");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: PersonJobTitle
Priority: 20
// note we include titles but not jobtitles in markup

(
 {Lookup.majorType == jobtitle}
 SPACE
)
(
 (TITLE)?
 ((FIRSTNAME | FIRSTNAMEAMBIG | INITIALS2)
  (SPACE)? 
 )
 (PREFIX)*
 (UPPER)
 (SPACE PERSONENDING)?
)
:person -->
  :person.TempPerson = {kind = "personName", rule = "PersonJobTitle"}


Rule: 	FirstPersonStop
Priority: 20
// surname contains stop words
// e.g. Mary And

(
 (FIRSTNAME (SPACE)?)+
):person
(
 (SPACE 
  ({Lookup.majorType == stop}|
   {Token.category == DT})
  (SPACE)?
 )
)
-->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "FirstPersonStop");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: NotFirstPersonStop
Priority: 50
// ambig first name and surname is stop word
// e.g. Will And

(
 ((FIRSTNAMEAMBIG (SPACE)?)+ | 
  {Token.category == PRP}|
  {Token.category == DT}
 )
 (SPACE {Lookup.majorType == stop}
  (SPACE)?
 )
)
:person -->
  :person.TempPerson = {kind = "negative", rule = "NotFirstPersonStop"}


Rule: NotPersonFull
Priority: 50
// A British

(
 {Token.category == DT}
 (SPACE)
)
(
 (PREFIX)*
 (UPPER)
):unknown
(
 (SPACE PERSONENDING)?
)
-->
{}

Rule: 	PersonFull
Priority: 10
// F.W. Jones
// Fred Jones

(
 {Token.category == DT}
 SPACE
)?
(
 ((FIRSTNAME | FIRSTNAMEAMBIG) (SPACE) )+
 (PREFIX)*
 (UPPER)
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFull");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: NotPersonFullReverse
Priority: 20
// XYZ, I
(
 (UPPER)
 {Token.string == ","}
 (SPACE)?
 {Token.category == PRP}
 (SPACE PERSONENDING)?
)
:unknown 
-->
{}

Rule: 	PersonFullReverse
Priority: 5
// Jones, F.W.
// don't allow Jones, Fred because too ambiguous
// Smith, TF

(
 {Token.category ==NNP}
 {Token.string == ","}
 (SPACE)?
 (INITIALS (SPACE)? )+ 
 (SPACE PERSONENDING)?
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonFullReverse");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}

Rule: PersonFullStop
Priority: 50
// G.Wilson Fri

(
 ((FIRSTNAME | FIRSTNAMEAMBIG) (SPACE)? )
 (PREFIX)* 
 (UPPER)
):person
(
 (SPACE)
 {Lookup.majorType == date}
)
-->
 :person.TempPerson = {kind = "personName", rule = "PersonFullStop"}


Rule:  PersonSaint
Priority: 50
// Note: ensure that it's not a Saints Day first
(
 ({Token.string == "St"} ({Token.string == "."})? |
 {Token.string == "Saint"})
 SPACE
 (FIRSTNAME)
 )
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonSaint");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


Rule: PersonLocAmbig
Priority: 40
// Ken London
// Susan Hampshire

// Christian name + Location --> Person's Name
(
 ({Lookup.majorType == person_first} |
  (INITIALS
   {Token.string == "."})
 )
   SPACE 
  {Lookup.majorType == location}
)
:person -->
{
 gate.FeatureMap features = Factory.newFeatureMap();
gate.AnnotationSet personSet = (gate.AnnotationSet)bindings.get("person");
gate.AnnotationSet firstPerson = (gate.AnnotationSet)personSet.get("FirstPerson");
if (firstPerson != null && firstPerson.size()>0)
{
  gate.Annotation personAnn = (gate.Annotation)firstPerson.iterator().next();
  features.put("gender", personAnn.getFeatures().get("gender"));
}
  features.put("kind", "personName");
  features.put("rule", "PersonLocAmbig");
annotations.add(personSet.firstNode(), personSet.lastNode(), "TempPerson",
features);
}


///////////////////////////////////////////////////////////////////
// Organisation Rules

Macro:  CDG
// cdg is something like "Ltd."
 (
  ({Lookup.majorType == cdg})|
  ({Token.string == ","} 
  (SPACE)
  {Lookup.majorType == cdg})
 )


Macro: SAINT
(
 ({Token.string == "St"} ({Token.string == "."})? |
 {Token.string == "Saint"})
)

Macro: CHURCH
(
{Token.string == "Church"}|{Token.string == "church"}|
{Token.string == "Cathedral"}|{Token.string == "cathedral"}|
{Token.string == "Chapel"}|{Token.string == "chapel"}
)

/////////////////////////////////////////////////////////////
Rule:	GazOrganization
Priority: 15

(
{Lookup.majorType == organization}
(SPACE {Lookup.majorType == organization})?
)
:orgName -->  
{
 gate.FeatureMap features = Factory.newFeatureMap();
// create an annotation set consisting of all the annotations for org 
gate.AnnotationSet orgSet = (gate.AnnotationSet)bindings.get("orgName");
// create an annotation set consisting of the annotation matching Lookup
gate.AnnotationSet org = (gate.AnnotationSet)orgSet.get("Lookup");
// if the annotation type Lookup doesn't exist, do nothing
if (org != null && org.size()>0)
{
// if it does exist, take the first element in the set
  gate.Annotation orgAnn = (gate.Annotation)org.iterator().next();
//propagate minorType feature (and value) from org
  features.put("orgType", orgAnn.getFeatures().get("minorType"));
}
// create some new features
  features.put("rule", "GazOrganization");
// create a TempOrg annotation and add the features we've created
annotations.add(orgSet.firstNode(), orgSet.lastNode(), "TempOrganization",
features);
}


Rule:	OrgXandY
Priority: 20

// Bradford & Bingley
// Bradford & Bingley Ltd
(
 {Token.category == IN}
 (SPACE)
)?

(
 ({Token.category == NNP}
  (SPACE)? )+

 {Token.string == "&"}

 ((SPACE)?
  {Token.orth == upperInitial}
 )+

 (SPACE CDG)?

)
:orgName -->
  :orgName.TempOrganization = {orgType = "unknown", rule = "OrgXandY"}


Rule:OrgUni
Priority: 25
// University of Sheffield
// Sheffield University
// A Sheffield University
(
 {Token.string == "University"}
 SPACE
 {Token.string == "of"}
 (SPACE 
 {Token.orth == upperInitial})+
)
:orgName -->
  :orgName.TempOrganization = {orgType = "org", rule = "OrgDept"}



Rule: OrgDept
Priority: 25
// Department of Pure Mathematics and Physics

(
 {Token.string == "Department"}
 SPACE
 {Token.string == "of"}
 (SPACE 
 {Token.orth == upperInitial})+
 (SPACE
  {Token.string == "and"}
  (SPACE 
   {Token.orth == upperInitial})+
 )?
)
:orgName -->
  :orgName.TempOrganization = {orgType = "department", rule = "OrgDept"}



Rule:	OrgXKey
Priority: 15

// Aaaa Ltd.
// Xxx Services Ltd. 
// but NOT A XXX Services Ltd.
(
 {Token.category == DT}
 (SPACE)
)?
(
  ({Token.orth == upperInitial} | 
   {Token.orth == allCaps}|
   {Token.orth == mixedCaps}
  )
  SPACE
  (({Token.orth == upperInitial} | {Token.orth == allCaps})
   SPACE)*
 {Lookup.majorType == org_key}
 (SPACE {Lookup.majorType == org_ending})?
)
:orgName -->
  :orgName.TempOrganization = {orgType = "unknown",rule = "OrgXKey"}


Rule:	OrgXEnding
Priority: 20

// Coca Cola Co.

(
 {Token.category == DT}
 (SPACE)
)?
(
  ({Token.orth == upperInitial} | 
   {Token.orth == allCaps}|
   {Token.orth == mixedCaps})
  SPACE
  (({Token.orth == upperInitial} |
   {Token.orth == allCaps})
   SPACE)?
 {Lookup.majorType == cdg}
)
:orgName -->
  :orgName.TempOrganization = {orgType = "unknown", rule = "OrgXEnding"}



Rule:	OrgXandYKey
Priority: 20

// Aaaa Ltd.
// Xxx Services Ltd. 
// AA and BB Services Ltd.
// but NOT A XXX Services Ltd.
(
 {Token.category == DT}
 (SPACE)
)?
(
  ({Token.orth == upperInitial} | 
   {Token.orth == allCaps})
  SPACE
  (({Token.string == "and"} | 
    {Token.string == "&"})
   SPACE
   ({Token.orth == upperInitial} | 
   {Token.orth == allCaps})
   SPACE
  )
  (({Token.orth == upperInitial}| 
    {Token.orth == allCaps})
   SPACE)*
 {Lookup.majorType == org_key}
 (SPACE {Lookup.majorType == org_ending})?
)
:orgName -->
  :orgName.TempOrganization = {orgType = "unknown",rule = "OrgXandYKey"}


Rule:	OrgXsKeyBase
Priority: 20
 
// Gandy's Circus
// Queen's Ware

(
  (({Token.orth == upperInitial} | 
    {Token.orth == allCaps})
   SPACE)?
  (({Token.orth == upperInitial} | 
    {Token.orth == allCaps})
   SPACE)?
  ({Token.orth == upperInitial}
   {Token.string == "'"}
   ({Token.string == "s"})?
   SPACE)
 ({Lookup.majorType == org_key}|
  {Lookup.majorType == org_base})
)
:orgName -->
  :orgName.TempOrganization = {kind = "orgName", rule = "OrgXsKeybase"}



Rule: NotOrgXBase
Priority: 100
// not things like British National
// or The University
// NOTE: not sure if we want this for emails or not

(
 ({Token.category == DT}
   SPACE)?
)
(
 ({Lookup.majorType == country_adj}|
  {Token.orth == lowercase})
 SPACE
 ({Lookup.majorType == org_base}|
  {Lookup.majorType == govern_key})
)
:orgName -->
  :orgName.Temp = {kind = "notorgName", rule = "NotOrgXBase"}


Rule:	OrgXBase
Priority: 30

// same as OrgXKey but uses base instead of key
// includes govern_key e.g. academy
// Barclays Bank
// Royal Academy of Art
(
 (
  {Token.category == DT}
  SPACE
 )?
)
(
 ({Token.orth == upperInitial} | 
  {Token.orth == allCaps} |
  {Token.orth == mixedCaps}
 )
  SPACE
  ({Token.orth == upperInitial}
   SPACE)?
 ({Token.orth == upperInitial}
   SPACE)?
 ({Lookup.majorType == org_base}|
  {Lookup.majorType == govern_key})
 (SPACE
  {Token.string == "of"}
  SPACE
  {Token.orth == upperInitial}
  (SPACE
  {Token.orth == upperInitial}
  )?
 )?
)
:orgName -->
  :orgName.TempOrganization = {orgType = "unknown",rule = "OrgXBase"}


Rule:	OrgPreX
Priority: 30

// Royal Tuscan

(
 {Lookup.majorType == org_pre}
 (SPACE
  {Token.orth == upperInitial})+
 (SPACE {Lookup.majorType == org_ending})?
)
:orgName -->
  :orgName.TempOrganization = {orgType = "unknown",rule = "OrgPreX"}




Rule: OrgChurch
Priority: 50
// St. Andrew's Church

(
  (SAINT)
  SPACE
  {Token.orth == upperInitial}
  {Token.string == "'"}({Token.string == "s"})?
  SPACE
  (CHURCH)
)
:orgName -->
  :orgName.TempOrganization = {orgType = "org", rule = "OrgChurch"}


Rule:OrgPersonAmbig
Priority: 30
// Alexandra Pottery should be org not person
// overrides PersonFull

(
 (FIRSTNAME (SPACE)? )
 ({Lookup.majorType == org_key}|
  {Lookup.majorType == org_base})
 (SPACE {Lookup.majorType == org_ending})?
)
:org 
-->
 :org.TempOrganization = {orgType = "unknown",rule = "OrgPersonAmbig"}

 

/////////////////////////////////////////////////////////////////
// Location rules


Rule: 	Location1
Priority: 25
// Lookup = city, country, province, region, water

// Western Europe
// South China sea
(
 (
  {Token.category == DT}
  SPACE
 )?
)
(
 ({Lookup.majorType == loc_pre_key}
  SPACE)?
 {Lookup.majorType == location}
 (SPACE
  {Lookup.majorType == loc_post_key})?
)
:locName -->

{
 gate.FeatureMap features = Factory.newFeatureMap();
// create an annotation set consisting of all the annotations for org 
gate.AnnotationSet locSet = (gate.AnnotationSet)bindings.get("locName");
// create an annotation set consisting of the annotation matching Lookup
gate.AnnotationSet loc = (gate.AnnotationSet)locSet.get("Lookup");
// if the annotation type Lookup doesn't exist, do nothing
if (loc != null && loc.size()>0)
{
// if it does exist, take the first element in the set
  gate.Annotation locAnn = (gate.Annotation)loc.iterator().next();
//propagate minorType feature (and value) from loc
  features.put("locType", locAnn.getFeatures().get("minorType"));
}
// create some new features
  features.put("rule", "Location1");
// create a TempLoc annotation and add the features we've created
annotations.add(locSet.firstNode(), locSet.lastNode(), "TempLocation",
features);
}

Rule:	GazLocation
Priority: 50
(
 (
  {Token.category == DT}
  SPACE
 )?
)
  ({Lookup.majorType == location}
  )
:locName
  --> 	
{
 gate.FeatureMap features = Factory.newFeatureMap();
// create an annotation set consisting of all the annotations for org 
gate.AnnotationSet locSet = (gate.AnnotationSet)bindings.get("locName");
// create an annotation set consisting of the annotation matching Lookup
gate.AnnotationSet loc = (gate.AnnotationSet)locSet.get("Lookup");
// if the annotation type Lookup doesn't exist, do nothing
if (loc != null && loc.size()>0)
{
// if it does exist, take the first element in the set
  gate.Annotation locAnn = (gate.Annotation)loc.iterator().next();
//propagate minorType feature (and value) from loc
  features.put("locType", locAnn.getFeatures().get("minorType"));
}
// create some new features
  features.put("rule", "GazLocation");
// create a TempLoc annotation and add the features we've created
annotations.add(locSet.firstNode(), locSet.lastNode(), "TempLocation",
features);
}

/////////////////////////////////////////////////////////////////


// Context-based Rules


Rule: FirstNameContext
Priority: 40
// Dear hiranya

(
 {Token.string == "Dear"}
 (SPACE)
)
(
 ({Token.orth == upperInitial} |
  {Token.orth == lowercase})
)
:person -->
  :person.TempPerson = {kind = "personName", rule = "FirstNameContext"}


Rule:InLoc1

(
 {Token.string == "in"}
 (SPACE)
)
(
 {Lookup.majorType == location, Token.orth == allCaps}
)
:locName
-->
 :locName.TempLocation = {kind = "locName", rule = InLoc1}


