// Horacio, Nov.2000

Phase: Split
//Input: Token SpaceToken Lookup
Options: control = appelt





Rule: Split1
Priority: 1000

// (Abbreviation) (".") (Upper case & Common Word) => no sentence boundary
// has the biggest priority

({Lookup.majorType == abbreviation})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Lookup.majorType == commonUpper})

-->

:split.NoSplit = { r=1}


Rule: Split2
Priority: 900

// (Word) (".") (Upper case & Common Word) => sentence boundary


({Token.kind == word })

({Token.string == "."})

:split 

(({SpaceToken})+

 {Lookup.majorType == commonUpper})

-->

:split.Split = { r=2}


Rule: Split16
Priority: 1000

// (Abbreviation) (".") (Upper case & Common Word) => no sentence boundary
// has the biggest priority

({Lookup.majorType == abbreviation})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Token.kind == number})

-->

:split.NoSplit = { r=16}


Rule: Split31
Priority: 800  
// (Lowercase) (Space) (Single) (".") (Common Word) => not sentence boundary
// Unfortunately we have to split this in 26 rules one for each letter "A", "B", etc.
// because Jape is
// unable to manage multiconditions on the context (Token.length=1,Token.orth=upperInitial}
// other solution is to have a list of letters in the gazetteer which is the solution 
// implemented here


({Token.orth == lowercase}
({SpaceToken})+
{Lookup.majorType== singleUpper})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Lookup.majorType == commonUpper})


-->

:split.Split = { r="31" }



Rule: Split33
Priority: 800  


({Token.kind == punctuation}
({SpaceToken})+
{Lookup.majorType== singleUpper})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Lookup.majorType == commonUpper})


-->

:split.Split = { r="33" }



Rule: Split32
Priority: 800  
// (Lowercase) (Space) (Single) (".") (not Common Word) => sentence boundary
// Unfortunately we have to split this in 26 rules one for each letter "A", "B", etc.
// because Jape is
// unable to manage multiconditions on the context (Token.length=1,Token.orth=upperInitial}
// other solution is to have a list of letters in the gazetteer which is the solution 
// implemented here


({Token.orth == lowercase}
({SpaceToken})+
{Lookup.majorType== singleUpper})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Token})


-->

:split.NoSplit = { r="32" }




Rule: Split34
Priority: 800  
// (Lowercase) (Space) (Single) (".") (not Common Word) => sentence boundary
// Unfortunately we have to split this in 26 rules one for each letter "A", "B", etc.
// because Jape is
// unable to manage multiconditions on the context (Token.length=1,Token.orth=upperInitial}
// other solution is to have a list of letters in the gazetteer which is the solution 
// implemented here


({Token.kind == punctuation}
({SpaceToken})+
{Lookup.majorType== singleUpper})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Token})


-->

:split.NoSplit = { r="34" }


Rule: Split4
Priority: 700  
// (".") (SPACES+) (Number) => Sentence Boundary  
// ex: it.     86 Markus


({Token.string == "."})

:split 

(({SpaceToken})+

 {Token.kind == number})


-->

:split.Split = { r="4" }




Rule: Split5
Priority: 600  
// (Number) (".") (SPACES+) (upperCase) => Sentence Boundary  
// ex: 1998.  They 

({Token.kind == number})

({Token.string == "."})

:split 

(({SpaceToken})+

 {Token.orth == upperInitial})


-->

:split.Split = { r="5" }



Rule: Split6
Priority: 500  
// (".") (SPACES) (CONTROL)  
//  ex: it.  
//   
/// New sentence

({Token.string == "."})

:split 

({Token.kind == space} {Token.kind == control})



-->

:split.Split = { r="6" }

Rule: Split7
Priority: 500  
// (".") (CONTROL) (SPACES)  
//  ex: it.  
//   
/// New sentence

({Token.string == "."})

:split 

({Token.kind == control} {Token.kind == space})



-->

:split.Split = { r="7" }


Rule: Split8
Priority: 500  
// (Common) (".")  (SPACES)  => sentence boundary 

({Lookup.majorType == common})

({Token.string == "."})

:split 

({SpaceToken})



-->

:split.Split = { r="8" }


Rule: Split9
Priority: 400  
// (".")  ("<")  => sentence boundary 
// this is a rule for press association


({Token.string == "."})

:split 

({Token.string == "<"})



-->

:split.Split = { r="9" }



Rule: Split10
Priority: 400  
// ("?")  ("<")  => sentence boundary 
// this is a rule for press association


({Token.string == "?"})

:split 

({Token.string == "<"})



-->

:split.Split = { r="10" }



Rule: Split11
Priority: 400  
// ("!")  ("<")  => sentence boundary 
// this is a rule for press association


({Token.string == "!"})

:split 

({Token.string == "<"})



-->

:split.Split = { r="11" }


Rule: Split12
Priority: 400  
// (".") S(Quotes)  => sentence boundary 
// this is a rule for press association


({Token.string == "."})

:split 

(({SpaceToken})*
{Token.string == "\""})



-->

:split.Split = { r="12" }



Rule: Split13
Priority: 400  
// (".") (Quotes)  => sentence boundary 
// this is a rule for press association


({Token.string == "."})

:split 

(({SpaceToken})*
{Token.string == "'"})



-->

:split.Split = { r="13" }


Rule: Split14
Priority: 400  
// (Quotes) (".")  => sentence boundary 
// this is a rule for press association

({Token.string == "\""})
({Token.string == "."})

:split 





-->

:split.Split = { r="14" }


Rule: Split15
Priority: 400  
// (Quotes) (".")  => sentence boundary 
// this is a rule for press association

({Token.string == "'"})
({Token.string == "."})

:split 





-->

:split.Split = { r="15" }




//Rule: Split17
//Priority: 400  
//  (".") (<p>)  => sentence boundary 
//  if a perior is followed by a begin of paragraph (html) the end of sentence

//({Token.string == "."})

//:split 

	
// (({SpaceToken})+
//  {Paragraph})



//-->

//:split.Split = { r="17" }


Rule: Split18
Priority: 400  
//  (lowercase) (".") (Spaces) (Uppercase) => sentence boundary 

({Token.orth == lowercase})
({Token.string == "."})

:split 

 (({SpaceToken})+
  {Token.orth == upperInitial})



-->

:split.Split = { r="18" }



Rule: Split19
Priority: 400  
//  (Uppercase & Length>1) (".") (Spaces) (Uppercase) => sentence boundary 

({Token.kind == word})
({Token.string == "."})

:split 

 (({SpaceToken})+
  {Token.orth == upperInitial})



-->

:split.Split = { r="19" }


Rule: Split20
Priority: 400  
//  (".") (Token) => No sentence boundary 

({Token.string == "."})

:split 

 
  ({Token})



-->

:split.NoSplit = { r="20" }

Rule: Split100
Priority: 1 
//   (".") => sentence boundary 

({Token.string == "."})

:split 

 
  



-->

:split.Split = { r="100" }
